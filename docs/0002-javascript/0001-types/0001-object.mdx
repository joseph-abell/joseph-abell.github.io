# Object

Objects are the most basic building block of JS, and also the most amorphous.
An object is a collection of values. Each value is named, and can be of any type,
including other objects. Each value can be a different type to other values on the same object.

In other words, it's a blob of data and functionality, grouped up in a nice package.

Note: All of my examples are written in an immutable style. This means that values should not
change at the point of creation. This is a tradeoff of having less bugs, but makes an app
potentially heavier as it has more copies of data kicking around.

## Create Object

```JS
const cat = {
  name: 'Munro',
  age: 7,
  isAnnoying: true,
  talk: () => return 'meow'
}
```

You can also use bracket notation to add a value to an object whose key has been generated by code:

```JS
const var1 = 'name';

const cat = {
  [var1]: 'Munro',
  age: 7,
  isAnnoying: true,
  talk: () => return 'meow'
}

console.log(cat[var1]) // 'Munro'
console.log(cat?.name) // 'Munro'
```

## Values

### Create

```JS
const cat = {
  name: 'Munro',
  age: 7,
  isAnnoying: true,
  talk: () => return 'meow'
}

const newCat = { ...cat, isCute = true };

console.log(cat.isCute) // undefined
console.log(newCat.isCute) // true
```

### Read

#### Dot Notation

```JS
const cat = {
name: 'Munro',
age: 7,
isAnnoying: true,
talk: () => return 'meow'
}

console.log(cat.name) // 'Munro'
console.log(cat.talk()) // 'meow'
```

#### Bracket Notation

Bracket notationis sometimes needed when the key you are trying to access needs to be surrounded in
quotation marks to be read correctly. Without quotation marks, JS will try to do subtraction on is
and annoying.

You can also use it for values created previously.

```JS

const dynamicValue: 'name';

const cat = {
  name: 'Munro',
  age: 7,
  "is-annoying": true,
  talk: () => return 'meow'
}

console.log(cat['is-annoying']) // true
console.log(cat[dynamicValue]) // 'Munro'
```

### Update

```JS
const cat = {
  name: 'Munro',
  age: 7,
  isAnnoying: true,
  talk: () => return 'meow'
}

const newCat = { ...cat, isAnnoying = false };

console.log(cat.isAnnoying) // true
console.log(newCat.isAnnoying) // false
```

### Delete

```JS
const cat = {
  name: 'Munro',
  age: 7,
  isAnnoying: true,
  talk: () => return 'meow'
}

const { age, ...newCat } = cat;

console.log(newCat);
```

## Footguns

### Logging an object

If you want to console log an object to see a value, you probably expect to see the value
at the point of when you logged the value. If you have logging a complex object, rather than
something as simple as a string, this assumption is probably incorrect. Look at the following
example:

```JS
const a = {
  b: 'b',
  c: 'c',
  d: 'd',
  e: 'e'
}

console.log(a),

a.b = 'f';
```

You would expect a to show the value b to be 'b'. But the development console will show you the current
value, not the one at the time of logging. To get around this, you'll need to stick the object in a
JSON.stringify function, or just log the single value you care about.

## TODO

- Object destructuring

## Credits

- [MDN][mdn]

[mdn]: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics
